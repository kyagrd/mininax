-- vim: sw=2: ts=2: expandtab: syntax=haskell:
data Unit = Unit ;
data Bool = False | True ;
data Maybe a = Nothing | Just a ;
data Either a b = Left a | Right b ;
data Pair a b = Pair a b ;

id = \x -> x ;
x = id;
z = {True -> True; False -> False};
z2 = {Nothing -> False; Just x -> True};
b = True;
c = x b;
p = Pair ;
z3 = Pair True False;

data N r = Z | S r ;
-- Use (In 0 ...) for regular recursive values without any index
zero = In 0 Z ;
succ = \n -> In 0 (S n) ;

one = succ zero ;
two = succ one ;
three = succ two ;

data L a r = N | C a r ;
nil = In 0 N ;
cons = \x -> \xs -> In 0 (C x xs) ;

z5 = cons nil nil ;
z6 = cons True nil ;


data P r a = PN | PC a (r (Pair a a)) ;
-- Use (In 1 ...) for recursive values with one index
pnil = In 1 PN ;
pcons = \x -> \xs -> In 1 (PC x xs) ;

z7 = pcons True (pcons (Pair False True) pnil) ;
z8 = pcons one (pcons (Pair two three) pnil) ;


data T a r {i} = TN | TC a (r { In 0 (S i) });
-- to test (In 1 ...) works for term indices
tnil = In 1 TN ;
tcons = \x -> \xs -> In 1 (TC x xs) ;

data V a r : { Mu N } -> * where
  { VN : V a r { In 0 Z }
  ; VC : a -> r { n } -> V a r { In 0 (S n) }
  } ;
vnil = In 1 VN ;
vcons = \x -> \xs -> In 1 (VC x xs) ;

data MM = MM (Mu N);
data MMM a = MMM (Mu P a);
data XX a : * where
  { D1 : a -> XX a
  ; D2 : (b -> a) -> b -> XX a
  } ;
data YY : * -> * where
  { DD1 : Mu N -> YY (Mu N)
  ; DD3 : (b -> a) -> b -> YY a
  } ;


-- pppp = mit add { S n -> n } ; -- must fail
z9 = { D1 n   -> succ n
     ; D2 f x -> f x
     } ;
-- z10 = { D1 n   -> succ n
--       ; D2 f x -> x -- must fail
--       } ;
flip = \f -> \x -> \y -> f y x ;
plus = mit add { Z   -> \m -> m
               ; S n -> \m -> succ (add n m) } ;
length = mit len { N -> zero; C x xs -> succ (len xs) } ;
psum = mit sum {{ a . (a -> Mu N) -> Mu N }}
           { PN      -> \f -> zero
           ; PC x xs -> \f -> plus (f x)
                                   (sum xs {Pair a b -> plus (f a) (f b)} )
           } ;
mult = mit mul { Z   -> \m -> zero
               ; S n -> \m -> plus m (mul n m)
               } ;
factorial = mpr fac cast { Z   -> one
                         ; S n -> mult (succ (cast n)) (fac n)
                         } ;
vlength = mit len {{ {n} . Mu N }} { VN -> zero ; VC x xs -> succ (len xs) } ;
vmap = \f -> mit map {{ {n} . Mu (V b) {n} }}
                 { VN -> vnil
                 ; VC x xs -> vcons (f x) (map xs)
                 } ;
n4 = plus (plus one one) (plus one one) ;
n5 = length z6 ;
n6 = length z5 ;
n7 = psum z8 id ;
n8 = flip psum ;
n9 = mult two three ;
n10 = factorial zero ;
n11 = factorial one ;
n12 = factorial two ;
n13 = factorial three ;
v1 = vcons one vnil ;
v2 = vcons two v1 ;
