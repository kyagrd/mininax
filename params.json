{"name":"Mininax","tagline":"Prototype implementation of the Nax language","body":"Mininax is a prototype reference implementation of the Nax programming language,\r\nwhich is described in [my Ph.D. dissertation draft](https://dl.dropboxusercontent.com/u/2589099/thesis/Nax_KiYungAhn_thesis_draft.pdf),\r\nbut only implements the core part of the language without syntactic sugars\r\n(e.g., type synonyms, fixpoint derivation). There are few other differences\r\nin the syntax compared to the version of the language in my dissertation.\r\nMininax supports case function syntax rather than case expression syntax.\r\nA case function is a list of case alternatives that awaits an argument\r\nto scrutinize. For example, `{ False -> e1; True -> e2 }` is a case function,\r\nwhich means `\\ x -> case x of { False -> e1; True -> e2 }` if you had case expressions. \r\nIn addition, mininax has better GADT declaration syntax than the language syntax\r\ndescribed in my Ph.D. dissertation.\r\n\r\nHere is an example mininax code.\r\n```haskell\r\ndata Unit = Unit ;                                                              \r\ndata Bool = False | True ;                                                      \r\ndata Maybe a = Nothing | Just a ;                                               \r\ndata Either a b = Left a | Right b ;                                            \r\ndata Pair a b = Pair a b ;                                                      \r\n                                                                                \r\nid = \\x -> x ;                                                                  \r\nflip = \\f -> \\x -> \\y -> f y x ;                                                \r\nx = id;                                                                         \r\nz = {True -> True; False -> False};                                             \r\nz2 = {Nothing -> False; Just x -> True};                                        \r\nb = True;                                                                       \r\nc = x b;                                                                        \r\np = Pair ;                                                                      \r\nz3 = Pair True False;                                                           \r\n                                                                                \r\ndata N r = Z | S r ;                                                            \r\n-- Use (In 0 ...) for regular recursive values without any index                \r\nzero = In 0 Z ;                                                                 \r\nsucc = \\n -> In 0 (S n) ;                                                       \r\n                                                                                \r\none = succ zero ;                                                               \r\ntwo = succ one ;                                                                \r\nthree = succ two ;                                                              \r\n                                                                                \r\nplus = mit add { Z   -> \\m -> m                                                 \r\n               ; S n -> \\m -> succ (add n m) } ;                                \r\nmult = mit mul { Z   -> \\m -> zero                                              \r\n               ; S n -> \\m -> plus m (mul n m)                                  \r\n               } ;\r\nfactorial = mpr fac cast { Z   -> one\r\n                         ; S n -> mult (succ (cast n)) (fac n)\r\n                         } ;\r\n\r\nn4 = plus (plus one one) (plus one one) ;\r\nn9 = mult two three ;\r\nn10 = factorial zero ;\r\nn11 = factorial one ;\r\nn12 = factorial two ;\r\nn13 = factorial three ;\r\n\r\ndata L a r = N | C a r ;\r\nnil = In 0 N ;\r\ncons = \\x -> \\xs -> In 0 (C x xs) ;\r\n\r\nz5 = cons nil nil ;\r\nz6 = cons True nil ;\r\n\r\nlength = mit len { N -> zero; C x xs -> succ (len xs) } ;\r\n\r\nn5 = length z6 ;\r\nn6 = length z5 ;\r\n\r\n-- term indices in ADT declaration\r\ndata T a r {i} = TN | TC a (r { `succ i });\r\n-- to test (In 1 ...) works for term indices\r\ntnil = In 1 TN ;\r\ntcons = \\x -> \\xs -> In 1 (TC x xs) ;\r\n\r\ndata P r a = PN | PC a (r (Pair a a)) ;\r\n-- Use (In 1 ...) for recursive values with one index\r\npnil = In 1 PN ;\r\npcons = \\x -> \\xs -> In 1 (PC x xs) ;\r\n\r\nz7 = pcons True (pcons (Pair False True) pnil) ;\r\nz8 = pcons one (pcons (Pair two three) pnil) ;\r\nkkk = \\x -> \\y -> x ;\r\npsum = mit sum {{ a . (a -> Mu N) -> Mu N }}\r\n           { PN      -> \\f -> zero\r\n           ; PC x xs -> \\f -> plus (f x) \r\n                                   (sum xs {Pair a b -> plus (f a) (f b)})\r\n           } ;\r\n\r\nn7 = psum z8 id ;\r\nn8 = flip psum ;\r\nn14 = flip psum id z8 ;\r\n\r\ndata V a r : { Mu N } -> * where\r\n  { VN : V a r { `zero }\r\n  ; VC : a -> r { n } -> V a r { `succ n }\r\n  } ;\r\n\r\nvnil = In 1 VN ;\r\nvcons = \\x -> \\xs -> In 1 (VC x xs) ;\r\n\r\nv1 = vcons one vnil ;\r\nv2 = vcons two v1 ;\r\n\r\nvlength = mit len {{ {n} . Mu N }}\r\n              { VN -> zero\r\n              ; VC x xs -> succ (len xs)\r\n              } ;\r\n\r\nvmap = \\f -> mit map {{ {n} . Mu (V b) {n} }}\r\n                 { VN      -> vnil\r\n                 ; VC x xs -> vcons (f x) (map xs)\r\n                 } ;\r\n\r\nvapp = mit app {{ {n} . Mu (V b) {m} -> Mu (V b) {`plus n m} }}\r\n            { VN      -> \\ys -> ys\r\n            ; VC x xs -> \\ys -> vcons x (app xs ys)\r\n            } ;\r\n\r\nn15 = vlength v2 ;\r\nv3 = vapp v2 v1 ;\r\nv4 = vmap succ v3 ;\r\n```\r\n\r\nRunining `mininax test.mininax` will give results of\r\nkind inference and type inference.\r\n```\r\nshell-prmompt> mininax test.mininax\r\nUnit : *\r\nBool : *\r\nMaybe : * -> *\r\nEither : * -> * -> *\r\nPair : * -> * -> *\r\nN : * -> *\r\nL : * -> * -> *\r\nT : * -> ({Mu N} -> *) -> {Mu N} -> *\r\nP : (* -> *) -> * -> *\r\nV : * -> ({Mu N} -> *) -> {Mu N} -> *\r\n\r\nUnit : Unit\r\nTrue : Bool\r\nFalse : Bool\r\nJust : a -> Maybe a\r\nNothing : Maybe a\r\nRight : b -> Either a b\r\nLeft : a -> Either a b\r\nPair : a -> b -> Pair a b\r\nid : _6 -> _6\r\nflip : (_12 -> _10 -> a14) -> _10 -> _12 -> a14\r\nx : _15 -> _15\r\nz : Bool -> Bool\r\nz2 : Maybe a16 -> Bool\r\nb : Bool\r\nc : Bool\r\np : a25 -> b24 -> Pair a25 b24\r\nz3 : Pair Bool Bool\r\nS : r -> N r\r\nZ : N r\r\nzero : Mu N\r\nsucc : Mu N -> Mu N\r\none : Mu N\r\ntwo : Mu N\r\nthree : Mu N\r\nplus : Mu N -> Mu N -> Mu N\r\nmult : Mu N -> Mu N -> Mu N\r\nfactorial : Mu N -> Mu N\r\nn4 : Mu N\r\nn9 : Mu N\r\nn10 : Mu N\r\nn11 : Mu N\r\nn12 : Mu N\r\nn13 : Mu N\r\nC : a -> r -> L a r\r\nN : L a r\r\nnil : Mu (L a110)\r\ncons : _113 -> Mu (L _113) -> Mu (L _113)\r\nz5 : Mu (L (Mu (L a122)))\r\nz6 : Mu (L Bool)\r\nlength : Mu (L a136) -> Mu N\r\nn5 : Mu N\r\nn6 : Mu N\r\nTC : a -> r {In 0 (S i)} -> T a r {i}\r\nTN : T a r {i}\r\ntnil : Mu (T a168) {i166}\r\ntcons : _172 -> Mu (T _172) {In 0 (S i175)} -> Mu (T _172) {i175}\r\nPC : a -> r (Pair a a) -> P r a\r\nPN : P r a\r\npnil : Mu P a187\r\npcons : _192 -> Mu P (Pair _192 _192) -> Mu P _192\r\nz7 : Mu P Bool\r\nz8 : Mu P (Mu N)\r\nkkk : _224 -> _226 -> _224\r\npsum : Mu P a230 -> (a230 -> Mu N) -> Mu N\r\nn7 : Mu N\r\nn8 : (a283 -> Mu N) -> Mu P a283 -> Mu N\r\nn14 : Mu N\r\nVC : a301 -> r300 {n302} -> V a301 r300 {In 0 (S n302)}\r\nVN : V a r {In 0 Z}\r\nvnil : Mu (V a319) {In 0 Z}\r\nvcons : _323 -> Mu (V _323) {n326} -> Mu (V _323) {In 0 (S n326)}\r\nv1 : Mu (V (Mu N)) {In 0 (S (In 0 Z))}\r\nv2 : Mu (V (Mu N)) {In 0 (S (In 0 (S (In 0 Z))))}\r\nvlength : Mu (V a348) {n345} -> Mu N\r\nvmap : (a383 -> _403) -> Mu (V a383) {n380} -> Mu (V _403) {n380}\r\nvapp : Mu (V _448) {n422} -> Mu (V _448) {m420} -> Mu (V _448) {\r\n    mit add461 {\r\n      Z -> \\ m462 -> m462 ;\r\n      S n463 -> \\ m464 -> In 0 (S (add461 n463 m464)) \r\n    }\r\n    n422 m420 \r\n  }\r\n  \r\nn15 : Mu N\r\nv3 : Mu (V (Mu N)) {In 0 (S (In 0 (S (In 0 (S (In 0 Z))))))}\r\nv4 : Mu (V (Mu N)) {In 0 (S (In 0 (S (In 0 (S (In 0 Z))))))}\r\n```\r\n\r\nYou can try `-h` or `--help` option for more information.\r\n```\r\nshell-prmompt> mininax -h\r\nminiax - command line program for the mininax langauge\r\n\r\nUsage: mininax [-k|--kind] [-t|--type] [-e|--eval] [-a|--all] [FILE]\r\n  mininax command line program\r\n\r\nAvailable options:\r\n  -h,--help                Show this help text\r\n  -k,--kind                Kind Inference for type constructors\r\n  -t,--type                Type Inference for data constructors and definitions\r\n  -e,--eval                Evaluate definitions\r\n  -a,--all                 Kind Infer, Type Infer, and Evaluate the program\r\n  FILE                     File path argument\r\n```\r\n\r\nUsing either `-e` option or `-a` option,\r\nyou can examine values of top level definitions.\r\n\r\n```\r\nshell-prmompt> mininax -e test.mininax\r\nid = \\ x -> x ;\r\nflip = \\ f -> \\ x -> \\ y -> f y x ;\r\nx = \\ x -> x ;\r\nz = {\r\n  True -> True ;\r\n  False -> False \r\n}\r\n ;\r\nz2 = {\r\n  Nothing -> False ;\r\n  Just x -> True \r\n}\r\n ;\r\nb = True ;\r\nc = True ;\r\np = Pair ;\r\nz3 = Pair True False ;\r\nzero = In 0 Z ;\r\nsucc = \\ n -> In 0 (S n) ;\r\none = In 0 (S (In 0 Z)) ;\r\ntwo = In 0 (S (In 0 (S (In 0 Z)))) ;\r\nthree = In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))) ;\r\nplus = mit add {\r\n  Z -> \\ m -> m ;\r\n  S n -> \\ m -> succ (add n m)\r\n}\r\n ;\r\nmult = mit mul {\r\n  Z -> \\ m -> zero ;\r\n  S n -> \\ m -> plus m (mul n m)\r\n}\r\n ;\r\nfactorial = mpr fac cast {\r\n  Z -> one ;\r\n  S n -> mult (succ (cast n)) (fac n)\r\n}\r\n ;\r\nn4 = In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))) ;\r\nn9 = In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))))))) ;\r\nn10 = In 0 (S (In 0 Z)) ;\r\nn11 = In 0 (S (In 0 Z)) ;\r\nn12 = In 0 (S (In 0 (S (In 0 Z)))) ;\r\nn13 = In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))))))) ;\r\nnil = In 0 N ;\r\ncons = \\ x -> \\ xs -> In 0 (C x xs) ;\r\nz5 = In 0 (C (In 0 N) (In 0 N)) ;\r\nz6 = In 0 (C True (In 0 N)) ;\r\nlength = mit len {\r\n  N -> zero ;\r\n  C x xs -> succ (len xs)\r\n}\r\n ;\r\nn5 = In 0 (S (In 0 Z)) ;\r\nn6 = In 0 (S (In 0 Z)) ;\r\ntnil = In 1 TN ;\r\ntcons = \\ x -> \\ xs -> In 1 (TC x xs) ;\r\npnil = In 1 PN ;\r\npcons = \\ x -> \\ xs -> In 1 (PC x xs) ;\r\nz7 = In 1 (PC True (In 1 (PC (Pair False True) (In 1 PN)))) ;\r\nz8 = In 1 (PC (In 0 (S (In 0 Z))) (In 1 (PC (Pair (In 0 (S (In 0 (S (In 0 Z))))) (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))) (In 1 PN)))) ;\r\nkkk = \\ x -> \\ y -> x ;\r\npsum = mit sum {{ a . (a -> Mu N) -> Mu N }} {\r\n  PN -> \\ f -> zero ;\r\n  PC x xs -> \\ f -> plus (f x) (sum xs {Pair a b -> plus (f a) (f b)} ) \r\n}\r\n ;\r\nn7 = In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))))))) ;\r\nn8 = \\ x -> \\ y -> mit sum {{ a . (a -> Mu N) -> Mu N }} {\r\n  PN -> \\ f -> zero ;\r\n  PC x xs -> \\ f -> plus (f x) (sum xs {Pair a b -> plus (f a) (f b)} ) \r\n}\r\ny x ;\r\nn14 = In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 (S (In 0 Z)))))))))))) ;\r\nvnil = In 1 VN ;\r\nvcons = \\ x -> \\ xs -> In 1 (VC x xs) ;\r\nv1 = In 1 (VC (In 0 (S (In 0 Z))) (In 1 VN)) ;\r\nv2 = In 1 (VC (In 0 (S (In 0 (S (In 0 Z))))) (In 1 (VC (In 0 (S (In 0 Z))) (In 1 VN)))) ;\r\nvlength = mit len {{ {n} . Mu N }} {\r\n  VN -> zero ;\r\n  VC x xs -> succ (len xs)\r\n}\r\n ;\r\nvmap = \\ f -> mit map {{ {n} . Mu (V b) {n} }} {\r\n  VN -> vnil ;\r\n  VC x xs -> vcons (f x) (map xs)\r\n}\r\n ;\r\nvapp = mit app {{ {n} . Mu (V b) {m} -> Mu (V b) {`plus n m} }} {\r\n  VN -> \\ ys -> ys ;\r\n  VC x xs -> \\ ys -> vcons x (app xs ys)\r\n}\r\n ;\r\nn15 = In 0 (S (In 0 (S (In 0 Z)))) ;\r\nv3 = In 1 (VC (In 0 (S (In 0 (S (In 0 Z))))) (In 1 (VC (In 0 (S (In 0 Z))) (In 1 (VC (In 0 (S (In 0 Z))) (In 1 VN)))))) ;\r\nv4 = In 1 (VC (In 0 (S (In 0 (S (In 0 (S (In 0 Z))))))) (In 1 (VC (In 0 (S (In 0 (S (In 0 Z))))) (In 1 (VC (In 0 (S (In 0 (S (In 0 Z))))) (In 1 VN)))))) ;\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}